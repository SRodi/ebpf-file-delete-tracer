package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"golang.org/x/sys/unix"
)

const bpfProgPath = "./trace_file_delete.o"
const memLockLimit = 64 * 1024 * 1024 // 64 MiB
// main sets up an eBPF program to monitor and prevent file deletions.
// It performs the following steps:
// 1. Sets the RLIMIT_MEMLOCK resource limit to allow locking memory for eBPF.
// 2. Loads the compiled eBPF program from an ELF file.
// 3. Creates a new eBPF collection from the loaded program.
// 4. Attaches the eBPF program to the "sys_enter_unlinkat" tracepoint to monitor file deletions.
// 5. Sets up a perf event reader to read events generated by the eBPF program.
// 6. Handles system signals for graceful shutdown.
// 7. Reads and prints the output from the eBPF program, which includes the PID, command, and filename of the process attempting to delete a file.
func main() {
	// Set the RLIMIT_MEMLOCK resource limit
	var rLimit unix.Rlimit
	rLimit.Cur = memLockLimit
	rLimit.Max = memLockLimit
	if err := unix.Setrlimit(unix.RLIMIT_MEMLOCK, &rLimit); err != nil {
		log.Fatalf("Failed to set RLIMIT_MEMLOCK: %v", err)
	}

	// Load the compiled eBPF program from ELF
	spec, err := ebpf.LoadCollectionSpec(bpfProgPath)
	if err != nil {
		log.Fatalf("Failed to load eBPF program: %v", err)
	}

	// Create a new eBPF Collection
	coll, err := ebpf.NewCollection(spec)
	if err != nil {
		log.Fatalf("Failed to create eBPF collection: %v", err)
	}
	defer coll.Close()

	// Attach the eBPF program to a tracepoint
	tp, err := link.Tracepoint("syscalls", "sys_enter_unlinkat", coll.Programs["trace_unlinkat"], nil)
	if err != nil {
		log.Fatalf("Failed to attach tracepoint: %v", err)
	}
	defer tp.Close()

	// Set up a perf event reader to read the output from the eBPF program
	eventsMap, ok := coll.Maps["events"]
	if !ok {
		log.Fatalf("Failed to find events map in eBPF collection")
	}
	rd, err := perf.NewReader(eventsMap, os.Getpagesize())
	if err != nil {
		log.Fatalf("Failed to create perf event reader: %v", err)
	}
	defer rd.Close()

	// Handle signals for graceful shutdown
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

	// Goroutine to handle graceful shutdown on receiving a signal
	go func() {
		<-sig
		rd.Close()
		tp.Close()
		os.Exit(0)
	}()

	// Read and print the output from the eBPF program
	var event struct {
		Pid      uint32
		Comm     [16]byte
		Filename [256]byte
	}

	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, perf.ErrClosed) {
				break
			}
			log.Printf("Failed to read from perf event reader: %v", err)
			continue
		}

		if err := binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &event); err != nil {
			log.Printf("Failed to parse perf event: %v", err)
			continue
		}

		fmt.Printf("File deletion by PID %d (%s): %s\n", event.Pid, event.Comm, event.Filename)
	}
}
